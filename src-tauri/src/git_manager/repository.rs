use crate::database::connection::Database;
use git2::{Repository, Signature};
use tokio::fs;
use chrono::Utc;

/// Initialize master repository for all game saves
pub async fn initialize_master_repo(
    db: &std::sync::Arc<tokio::sync::Mutex<Database>>,
    master_repo_path: &str
) -> Result<String, String> {
    // Ensure directory exists
    fs::create_dir_all(master_repo_path)
        .await
        .map_err(|e| format!("Failed to create saves directory: {}", e))?;

    // Initialize Git repository
    let repo = Repository::init(master_repo_path)
        .map_err(|e| format!("Failed to initialize master Git repository: {}", e))?;

    // Setup .gitignore
    setup_master_gitignore(master_repo_path).await?;

    // Make initial commit
    make_initial_commit(&repo, "Initial game saves repository")?;
    
    // Save repo config to DB (optional, but good for tracking)
    // In the original code, save_repo_config was called but it required game_id.
    // Here we are initializing the master repo, so maybe we don't need to save per-game config yet.
    // But wait, the original code had save_repo_config taking game_id.
    // initialize_master_repo in original code didn't take game_id.
    // Ah, wait. The original code's initialize_master_repo didn't call save_repo_config.
    // It was initialize_repository in git.rs that called save_repo_config.
    // git_manager/mod.rs initialize_master_repo just did init, gitignore, initial commit.
    
    Ok(format!("Master Git repository initialized at: {}", master_repo_path))
}

async fn setup_master_gitignore(repo_path: &str) -> Result<(), String> {
    let gitignore_path = format!("{}/.gitignore", repo_path);
    let gitignore_content = r#"
# Game Saves Repository
# Auto-generated by Save Steward
# Branch naming: gamename+save-name

# Game executable files
*.exe
*.app
*.bin

# System files
.DS_Store
Thumbs.db
desktop.ini

# Cache and temporary files
*.tmp
*.cache
*.log
node_modules/

# Keep save file extensions
*.sav
*.save
*.dat
*.json
*.ini
*.cfg
*.xml

# Game documentation
README.md
!README_GAME_SAVES.md
"#;

    fs::write(&gitignore_path, gitignore_content)
        .await
        .map_err(|e| format!("Failed to write master .gitignore: {}", e))
}

fn make_initial_commit(repo: &Repository, message: &str) -> Result<(), String> {
    let mut index = repo.index()
        .map_err(|e| format!("Failed to get index: {}", e))?;

    index.add_all(["*"].iter(), git2::IndexAddOption::DEFAULT, None)
        .map_err(|e| format!("Failed to add files: {}", e))?;

    index.write()
        .map_err(|e| format!("Failed to write index: {}", e))?;

    let tree_id = index.write_tree()
        .map_err(|e| format!("Failed to write tree: {}", e))?;

    let signature = repo.signature()
        .unwrap_or_else(|_| Signature::now("Save Steward", "save-steward@localhost").unwrap());

    let tree = repo.find_tree(tree_id)
        .map_err(|e| format!("Failed to find tree: {}", e))?;

    repo.commit(Some("HEAD"), &signature, &signature, message, &tree, &[])
        .map_err(|e| format!("Failed to create initial commit: {}", e))?;

    Ok(())
}

pub async fn save_repo_config(
    db: &std::sync::Arc<tokio::sync::Mutex<Database>>,
    game_id: i64, 
    repo_path: &str
) -> Result<(), String> {
    let db_guard = db.lock().await;
    let conn = db_guard.get_connection().await;
    
    conn.execute(
        "INSERT OR REPLACE INTO git_repositories (game_id, local_path, created_at, last_sync_at)
            VALUES (?, ?, ?, ?)",
        rusqlite::params![
            game_id,
            repo_path,
            Utc::now().to_rfc3339(),
            Utc::now().to_rfc3339()
        ]
    ).map_err(|e| format!("Failed to save repo config: {}", e))?;
    
    Ok(())
}
