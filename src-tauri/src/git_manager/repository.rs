use crate::database::connection::Database;
use git2::{Repository, Signature};
use tokio::fs;
use chrono::Utc;

/// Initialize master repository for all game saves
pub async fn initialize_master_repo(
    db: &std::sync::Arc<tokio::sync::Mutex<Database>>,
    master_repo_path: &str
) -> Result<String, String> {
    crate::logger::info("GIT_REPOSITORY", &format!("Initializing master Git repository at: {}", master_repo_path), None);
    
    // Ensure directory exists
    fs::create_dir_all(master_repo_path)
        .await
        .map_err(|e| {
            crate::logger::error("GIT_REPOSITORY", "Failed to create saves directory", Some(&e.to_string()));
            format!("Failed to create saves directory: {}", e)
        })?;
    
    crate::logger::debug("GIT_REPOSITORY", "Saves directory created successfully", None);

    // Initialize Git repository
    let repo = Repository::init(master_repo_path)
        .map_err(|e| {
            crate::logger::error("GIT_REPOSITORY", "Failed to initialize Git repository", Some(&e.to_string()));
            format!("Failed to initialize master Git repository: {}", e)
        })?;
    
    crate::logger::info("GIT_REPOSITORY", "Git repository initialized successfully", None);

    // Setup .gitignore
    setup_master_gitignore(master_repo_path).await?;
    
    // Setup .gitattributes for Git LFS
    setup_gitattributes(master_repo_path).await?;

    // Make initial commit
    make_initial_commit(&repo, "Initial game saves repository")
        .map_err(|e| {
            crate::logger::error("GIT_REPOSITORY", "Failed to create initial commit", Some(&e));
            e
        })?;
    
    crate::logger::info("GIT_REPOSITORY", "Initial commit created successfully", None);
    
    crate::logger::info("GIT_REPOSITORY", "Master Git repository initialization complete", Some(&format!("Path: {}", master_repo_path)));
    
    Ok(format!("Master Git repository initialized at: {}", master_repo_path))
}

async fn setup_master_gitignore(repo_path: &str) -> Result<(), String> {
    let gitignore_path = format!("{}/.gitignore", repo_path);
    let gitignore_content = r#"
# Game Saves Repository
# Auto-generated by Save Steward
# Branch naming: gamename-save-name

# Game executable files
*.exe
*.app
*.bin

# System files
.DS_Store
Thumbs.db
desktop.ini

# Cache and temporary files
*.tmp
*.cache
*.log
node_modules/

# Keep save file extensions
*.sav
*.save
*.dat
*.json
*.ini
*.cfg
*.xml

# Game documentation
README.md
!README_GAME_SAVES.md
"#;

    crate::logger::debug("GIT_REPOSITORY", &format!("Creating .gitignore at: {}", gitignore_path), None);
    
    fs::write(&gitignore_path, gitignore_content)
        .await
        .map_err(|e| {
            crate::logger::error("GIT_REPOSITORY", "Failed to write .gitignore", Some(&e.to_string()));
            format!("Failed to write master .gitignore: {}", e)
        })?;
    
    crate::logger::debug("GIT_REPOSITORY", "Successfully created .gitignore", None);
    Ok(())
}

async fn setup_gitattributes(repo_path: &str) -> Result<(), String> {
    let gitattributes_path = format!("{}/.gitattributes", repo_path);
    let gitattributes_content = r#"
# Git LFS Configuration for Game Saves
# Large save files should be tracked with LFS

# Common save file extensions
*.sav filter=lfs diff=lfs merge=lfs -text
*.save filter=lfs diff=lfs merge=lfs -text
*.dat filter=lfs diff=lfs merge=lfs -text
*.zst filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text
*.rar filter=lfs diff=lfs merge=lfs -text
*.7z filter=lfs diff=lfs merge=lfs -text

# Compressed save files
*.sa filter=lfs diff=lfs merge=lfs -text
*.bak filter=lfs diff=lfs merge=lfs -text
*.backup filter=lfs diff=lfs merge=lfs -text
"#;

    crate::logger::debug("GIT_REPOSITORY", &format!("Creating .gitattributes at: {}", gitattributes_path), None);
    
    fs::write(&gitattributes_path, gitattributes_content)
        .await
        .map_err(|e| {
            crate::logger::error("GIT_REPOSITORY", "Failed to write .gitattributes", Some(&e.to_string()));
            format!("Failed to write .gitattributes: {}", e)
        })?;
    
    crate::logger::debug("GIT_REPOSITORY", "Successfully created .gitattributes for Git LFS", None);
    Ok(())
}

fn make_initial_commit(repo: &Repository, message: &str) -> Result<(), String> {
    let mut index = repo.index()
        .map_err(|e| format!("Failed to get index: {}", e))?;

    index.add_all(["*"].iter(), git2::IndexAddOption::DEFAULT, None)
        .map_err(|e| format!("Failed to add files: {}", e))?;

    index.write()
        .map_err(|e| format!("Failed to write index: {}", e))?;

    let tree_id = index.write_tree()
        .map_err(|e| format!("Failed to write tree: {}", e))?;

    let signature = repo.signature()
        .unwrap_or_else(|_| Signature::now("Save Steward", "save-steward@localhost").unwrap());

    let tree = repo.find_tree(tree_id)
        .map_err(|e| format!("Failed to find tree: {}", e))?;

    repo.commit(Some("HEAD"), &signature, &signature, message, &tree, &[])
        .map_err(|e| format!("Failed to create initial commit: {}", e))?;

    Ok(())
}

pub async fn save_repo_config(
    db: &std::sync::Arc<tokio::sync::Mutex<Database>>,
    game_id: i64, 
    repo_path: &str
) -> Result<(), String> {
    let db_guard = db.lock().await;
    let conn = db_guard.get_connection().await;
    
    conn.execute(
        "INSERT OR REPLACE INTO git_repositories (game_id, local_path, created_at, last_sync_at)
            VALUES (?, ?, ?, ?)",
        rusqlite::params![
            game_id,
            repo_path,
            Utc::now().to_rfc3339(),
            Utc::now().to_rfc3339()
        ]
    ).map_err(|e| format!("Failed to save repo config: {}", e))?;
    
    Ok(())
}
