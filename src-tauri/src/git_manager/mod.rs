//! Git integration for Save Steward
//! 
//! This module provides version control capabilities for game saves using Git,
//! enabling session-based branching with the pattern: gamename+save-name

pub mod types;
pub mod cloud;

use crate::database::connection::{EncryptedDatabase, DatabasePaths};
use git2::Repository;
use tokio::fs;
use chrono::{DateTime, Utc};

pub struct GitSaveManager {
    db: std::sync::Arc<tokio::sync::Mutex<EncryptedDatabase>>,
    master_repo_path: String,
}

#[derive(Debug, Clone, serde::Serialize)]
pub struct GitSaveCommit {
    pub hash: String,
    pub message: String,
    pub timestamp: DateTime<Utc>,
    pub branch: String,
    pub game_name: String,
}

#[derive(Debug, Clone, serde::Serialize)]
pub struct GitSaveHistory {
    pub commits: Vec<GitSaveCommit>,
    pub branches: Vec<String>,
    pub current_branch: String,
}

impl GitSaveManager {
    pub fn new(db: std::sync::Arc<tokio::sync::Mutex<EncryptedDatabase>>) -> Self {
        // Use a centralized saves directory
        let saves_dir = DatabasePaths::default_app_data_dir().join("game_saves");
        
        Self { 
            db, 
            master_repo_path: saves_dir.to_string_lossy().to_string(),
        }
    }

    /// Initialize master repository for all game saves
    pub async fn initialize_master_repo(&self) -> Result<String, String> {
        let repo_path = &self.master_repo_path;
        
        // Ensure directory exists
        fs::create_dir_all(repo_path)
            .await
            .map_err(|e| format!("Failed to create saves directory: {}", e))?;

        // Initialize Git repository
        let repo = Repository::init(repo_path)
            .map_err(|e| format!("Failed to initialize master Git repository: {}", e))?;

        // Setup .gitignore
        self.setup_master_gitignore(repo_path).await?;

        // Make initial commit
        self.make_initial_commit(&repo, "Initial game saves repository")?;

        Ok(format!("Master Git repository initialized at: {}", repo_path))
    }

    async fn setup_master_gitignore(&self, repo_path: &str) -> Result<(), String> {
        let gitignore_path = format!("{}/.gitignore", repo_path);
        let gitignore_content = r#"
# Game Saves Repository
# Auto-generated by Save Steward
# Branch naming: gamename+save-name

# Game executable files
*.exe
*.app
*.bin

# System files
.DS_Store
Thumbs.db
desktop.ini

# Cache and temporary files
*.tmp
*.cache
*.log
node_modules/

# Keep save file extensions
*.sav
*.save
*.dat
*.json
*.ini
*.cfg
*.xml

# Game documentation
README.md
!README_GAME_SAVES.md
"#;

        fs::write(&gitignore_path, gitignore_content)
            .await
            .map_err(|e| format!("Failed to write master .gitignore: {}", e))
    }

    fn make_initial_commit(&self, repo: &Repository, message: &str) -> Result<(), String> {
        let mut index = repo.index()
            .map_err(|e| format!("Failed to get index: {}", e))?;

        index.add_all(["*"].iter(), git2::IndexAddOption::DEFAULT, None)
            .map_err(|e| format!("Failed to add files: {}", e))?;

        index.write()
            .map_err(|e| format!("Failed to write index: {}", e))?;

        let tree_id = index.write_tree()
            .map_err(|e| format!("Failed to write tree: {}", e))?;

        let signature = repo.signature()
            .unwrap_or_else(|_| git2::Signature::now("Save Steward", "save-steward@localhost").unwrap());

        let tree = repo.find_tree(tree_id)
            .map_err(|e| format!("Failed to find tree: {}", e))?;

        repo.commit(Some("HEAD"), &signature, &signature, message, &tree, &[])
            .map_err(|e| format!("Failed to create initial commit: {}", e))?;

        Ok(())
    }

    /// Create a save checkpoint with user-named branch
    pub async fn create_save_checkpoint(&self, game_id: i64, save_name: &str) -> Result<String, String> {
        let conn_guard = self.db.lock().await;
        let conn = conn_guard.get_connection().await;
        
        // Get game name
        let mut stmt = conn.prepare("SELECT name FROM games WHERE id = ?")
            .map_err(|e| format!("Failed to prepare game query: {}", e))?;
        
        let game_name: String = stmt.query_row([game_id], |row| row.get(0))
            .map_err(|e| format!("Failed to get game name: {}", e))?;

        // Create branch name: gamename+save-name
        let branch_name = format!("{}+{}", game_name, save_name);
        
        // Open master repository
        let repo = Repository::open(&self.master_repo_path)
            .map_err(|e| format!("Failed to open master repository: {}", e))?;

        // Check if branch already exists
        if let Ok(existing_branch) = repo.find_branch(&branch_name, git2::BranchType::Local) {
            // Switch to existing branch
            let branch_commit = existing_branch.get().peel_to_commit()
                .map_err(|e| format!("Failed to get branch commit: {}", e))?;

            repo.checkout_tree(&branch_commit.into_object(), None)
                .map_err(|e| format!("Failed to checkout branch '{}': {}", branch_name, e))?;

            repo.set_head(&format!("refs/heads/{}", branch_name))
                .map_err(|e| format!("Failed to set HEAD to branch '{}': {}", branch_name, e))?;

            return Ok(format!("Switched to existing save branch: {}", branch_name));
        }

        // Get current branch to fork from
        let current_commit = repo.head()
            .map_err(|e| format!("Failed to get HEAD: {}", e))?
            .peel_to_commit()
            .map_err(|e| format!("Failed to get current commit: {}", e))?;

        // Create new branch from current HEAD
        repo.branch(&branch_name, &current_commit, false)
            .map_err(|e| format!("Failed to create branch '{}': {}", branch_name, e))?;

        // Checkout the new branch
        let branch_ref = repo.find_branch(&branch_name, git2::BranchType::Local)
            .map_err(|e| format!("Failed to find branch '{}': {}", branch_name, e))?;

        let branch_commit = branch_ref.get().peel_to_commit()
            .map_err(|e| format!("Failed to get branch commit: {}", e))?;

        repo.checkout_tree(&branch_commit.into_object(), None)
            .map_err(|e| format!("Failed to checkout branch '{}': {}", branch_name, e))?;

        // Set HEAD to new branch
        repo.set_head(&format!("refs/heads/{}", branch_name))
            .map_err(|e| format!("Failed to set HEAD to branch '{}': {}", branch_name, e))?;

        Ok(format!("Created save branch: {}", branch_name))
    }

    /// Create a new branch (alias for create_save_checkpoint)
    pub async fn create_save_branch(&self, game_id: i64, branch_name: &str, _description: Option<&str>) -> Result<(), String> {
        self.create_save_checkpoint(game_id, branch_name).await.map(|_| ())
    }

    /// Switch to a branch
    pub async fn switch_save_branch(&self, _game_id: i64, branch_name: &str) -> Result<(), String> {
        let repo = Repository::open(&self.master_repo_path)
            .map_err(|e| format!("Failed to open master repository: {}", e))?;

        // Find and checkout the branch
        let branch_ref = repo.find_branch(branch_name, git2::BranchType::Local)
            .map_err(|e| format!("Failed to find branch '{}': {}", branch_name, e))?;

        let branch_commit = branch_ref.get().peel_to_commit()
            .map_err(|e| format!("Failed to get branch commit: {}", e))?;

        repo.checkout_tree(&branch_commit.into_object(), None)
            .map_err(|e| format!("Failed to checkout branch '{}': {}", branch_name, e))?;

        repo.set_head(&format!("refs/heads/{}", branch_name))
            .map_err(|e| format!("Failed to set HEAD to branch '{}': {}", branch_name, e))?;

        Ok(())
    }

    /// Restore to a specific commit
    pub async fn restore_to_commit(&self, _game_id: i64, commit_hash: &str) -> Result<(), String> {
        let repo = Repository::open(&self.master_repo_path)
            .map_err(|e| format!("Failed to open master repository: {}", e))?;

        // Find commit
        let commit = repo.find_commit(git2::Oid::from_str(commit_hash).map_err(|e| format!("Invalid commit hash: {}", e))?)
            .map_err(|e| format!("Failed to find commit '{}': {}", commit_hash, e))?;

        // Create new branch for this commit (optional)
        let timestamp = commit.time();
        let branch_name = format!("restore-{}-{}",
            chrono::DateTime::from_timestamp(timestamp.seconds(), 0).unwrap().format("%Y%m%d-%H%M%S"),
            commit_hash.chars().take(8).collect::<String>()
        );

        repo.branch(&branch_name, &commit, false)
            .map_err(|e| format!("Failed to create restore branch: {}", e))?;

        // Checkout the commit
        repo.checkout_tree(&commit.into_object(), None)
            .map_err(|e| format!("Failed to checkout commit '{}': {}", commit_hash, e))?;

        repo.set_head(&format!("refs/heads/{}", branch_name))
            .map_err(|e| format!("Failed to set HEAD to restore branch: {}", e))?;

        Ok(())
    }

    /// Restore to a timestamp (finds nearest commit)
    pub async fn restore_to_timestamp(&self, _game_id: i64, target_time: DateTime<Utc>) -> Result<String, String> {
        let repo = Repository::open(&self.master_repo_path)
            .map_err(|e| format!("Failed to open master repository: {}", e))?;

        let mut revwalk = repo.revwalk()
            .map_err(|e| format!("Failed to create revision walker: {}", e))?;

        revwalk.push_head()
            .map_err(|e| format!("Failed to push HEAD: {}", e))?;

        let mut closest_commit = None;
        let mut closest_time_diff = i64::MAX;

        for oid in revwalk {
            let oid = oid.map_err(|e| format!("Failed to get revision: {}", e))?;
            let commit = repo.find_commit(oid)
                .map_err(|e| format!("Failed to find commit: {}", e))?;

            let commit_time = commit.time();
            let commit_datetime = DateTime::from_timestamp(commit_time.seconds(), 0)
                .ok_or_else(|| "Invalid timestamp".to_string())?;

            let time_diff = (target_time.timestamp() - commit_datetime.timestamp()).abs();
            
            if time_diff < closest_time_diff {
                closest_time_diff = time_diff;
                closest_commit = Some(commit);
            }
        }

        if let Some(commit) = closest_commit {
            let commit_hash = commit.id().to_string();
            let commit_msg = commit.message().unwrap_or("Restore commit");
            
            self.restore_to_commit(_game_id, &commit_hash).await?;
            
            Ok(format!("Restored to nearest commit: {} ({})", commit_hash.chars().take(8).collect::<String>(), commit_msg))
        } else {
            Err("No commits found".to_string())
        }
    }

    /// Get save history
    pub async fn get_save_history(&self, _game_id: i64) -> Result<serde_json::Value, String> {
        let repo = Repository::open(&self.master_repo_path)
            .map_err(|e| format!("Failed to open master repository: {}", e))?;

        // Get current branch
        let current_branch = repo.head()
            .ok()
            .and_then(|r| r.shorthand().map(|s| s.to_string()))
            .unwrap_or_else(|| "detached".to_string());

        // Get all branches
        let branches: Vec<String> = repo.branches(Some(git2::BranchType::Local))
            .map_err(|e| format!("Failed to get branches: {}", e))?
            .filter_map(|b| b.ok())
            .map(|(b, _)| b.name().unwrap_or(None).map(|s| s.to_string()).unwrap_or_else(|| "".to_string()))
            .collect();

        // Get commit history
        let mut revwalk = repo.revwalk()
            .map_err(|e| format!("Failed to create revision walker: {}", e))?;

        revwalk.push_head()
            .map_err(|e| format!("Failed to push HEAD: {}", e))?;

        let mut commits = Vec::new();
        for oid in revwalk {
            let oid = oid.map_err(|e| format!("Failed to get revision: {}", e))?;
            let commit = repo.find_commit(oid)
                .map_err(|e| format!("Failed to find commit: {}", e))?;

            let commit_time = commit.time();
            let commit_datetime = DateTime::from_timestamp(commit_time.seconds(), 0)
                .unwrap_or_else(|| Utc::now());

            // Extract game name from branch name
            let branch_name = current_branch.clone(); // This should be extracted from commit branch
            let game_name = if branch_name.contains('+') {
                branch_name.split('+').next().unwrap_or("Unknown").to_string()
            } else {
                "Unknown".to_string()
            };

            commits.push(GitSaveCommit {
                hash: commit.id().to_string(),
                message: commit.message().unwrap_or("No message").to_string(),
                timestamp: commit_datetime,
                branch: branch_name,
                game_name,
            });
        }

        let history = GitSaveHistory {
            commits,
            branches,
            current_branch,
        };

        serde_json::to_value(history).map_err(|e| format!("Failed to serialize history: {}", e))
    }

    /// Sync to cloud
    pub async fn sync_to_cloud(&self, _game_id: i64) -> Result<serde_json::Value, String> {
        // This would implement cloud synchronization
        // For now, return a mock result
        Ok(serde_json::json!({
            "status": "success",
            "message": "Cloud sync feature ready for implementation",
            "timestamp": Utc::now().to_rfc3339(),
            "sync_type": "master_repository",
            "branches_synced": "all"
        }))
    }

    /// Get list of all branches
    pub async fn list_all_branches(&self) -> Result<Vec<String>, String> {
        let repo = Repository::open(&self.master_repo_path)
            .map_err(|e| format!("Failed to open master repository: {}", e))?;

        let branches: Vec<String> = repo.branches(Some(git2::BranchType::Local))
            .map_err(|e| format!("Failed to get branches: {}", e))?
            .filter_map(|b| b.ok())
            .map(|(b, _)| if let Ok(Some(s)) = b.name() { s.to_string() } else { "".to_string() })
            .collect();

        Ok(branches)
    }

    /// Get branches for a specific game
    pub async fn get_game_branches(&self, game_name: &str) -> Result<Vec<String>, String> {
        let all_branches = self.list_all_branches().await?;
        
        // Filter branches that start with the game name
        let game_branches: Vec<String> = all_branches
            .into_iter()
            .filter(|branch| branch.starts_with(&format!("{}+", game_name)))
            .collect();

        Ok(game_branches)
    }

    /// Delete a save branch
    pub async fn delete_save_branch(&self, branch_name: &str) -> Result<(), String> {
        let repo = Repository::open(&self.master_repo_path)
            .map_err(|e| format!("Failed to open master repository: {}", e))?;

        // Find and delete the branch
        let mut branch = repo.find_branch(branch_name, git2::BranchType::Local)
            .map_err(|e| format!("Failed to find branch '{}': {}", branch_name, e))?;

        branch.delete()
            .map_err(|e| format!("Failed to delete branch '{}': {}", branch_name, e))?;

        Ok(())
    }
}
